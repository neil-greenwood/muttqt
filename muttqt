#!/usr/bin/env python
"""muttqt - Mutt query tool.

Stores sent addresses to a database and queries the database and other sources
for email addresses."""
import os, sys
import argparse
import sqlite3
import email
import email.utils
import datetime as dt
import subprocess as sp
import shlex
from ConfigParser import ConfigParser

__version__ = "0.1.0"
__commit__ = None

# constants
CONFIGFILE = '~/.muttqt/muttqt.conf'
CONFIGFILE = os.path.expanduser(CONFIGFILE)
SQL_DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
LBDB_DATE_FORMAT = '%Y-%m-%d %H:%M'

class DataSource(object):
    """Base class for different data sources."""
    def __init__(self, cfg, getData=True):
        self.cfg = cfg
        self.data = []
        self.results = None
        self.query = None
        if getData:
            self.get_data()

    def print_results(self, numbered=False):
        """Print search results."""
        if numbered:
            # data = []
            # for i,d in enumerate(self.results):
            #     t = [str(i),]
            #     t.extend(d[1:])
            #     data.append(tuple(t))
            data = [tuple(t) for t in self.results]
            format_str = "%s\t%s\t%s\t%s"
        else:
            data = self.results
            format_str = "%s\t%s\t%s"
        i = len(self.results)
        print("{0} matches:".format(i))
        for i, string in enumerate(data):
            out = format_str % string
            print out.encode('utf-8')

    def search_data(self, query, sortby=None):
        """Search list data for query."""
        results = []
        query = query.lower()
        for line in self.data:
            if line[0].lower().find(query) > -1 or line[1].lower().find(query) > -1:
                results.append(line)
        self.query = query
        self.results = results

    def get_data(self):
        """Get the data from the data source."""
        pass

class AliasData(DataSource):
    """Uses the aliases file to get addresses."""
    def __init__(self, cfg, datatype='alias', getData=True):
        self.datatype = datatype
        super(AliasData, self).__init__(cfg, getData=getData)

    def get_data(self):
        """Read data from mutt alias files."""
        files = self.cfg.get(self.datatype, 'files').split(',')
        files = [os.path.expanduser(f.strip()) for f in files]
        self.files = files

        data = []
        for filename in files:
            try:
                fin = open(filename)
                lines = fin.readlines()
                fin.close()
            except:
                self.data = []
                return
            for line in lines:
                line = line.rstrip().split()
                if line != [] and line[0] == 'alias':
                    stuff = line[1:]
                    nick = "%s [%s]" % (stuff[0], os.path.basename(filename))
                    addy = " ".join(stuff[1:])
                    # some addresses seem to have escaped " - get rid of them
                    addy = addy.translate(None, '\\')
                    if addy.find(',') == -1:
                        addr = email.utils.parseaddr(addy)
                        # If we don't have a name, let's take the first part of
                        # the email address and use that
                        if addr[0] == '':
                            addr = (addr[1].split('@')[0], addr[1])
                        data.append((addr[1], addr[0], nick))
        self.data = data

class SentTxtData(DataSource):
    """Uses the 'senttxt' file to get addresses."""
    def __init__(self, cfg, datatype='senttxt', getData=True):
        self.datatype = datatype
        super(SentTxtData, self).__init__(cfg, getData=getData)

    def get_data(self):
        """Gets all data in the sent txt file.

        This file has the same format as an LBDB database."""
        filename = self.cfg.get('sent', 'txtfile')
        tempdat = ingest_LBDB(filename)
        data = []
        for i, data in enumerate(tempdat):
            lst = [str(i),]
            lst.extend(data)
            data.append(tuple(lst))
        self.data = data

    def get_all_sent(self):
        """Gets the data from the file without filtering."""
        self.results = self.data

    def prune_sent_before_date(self, date):
        """Remove addresses from sent txt file prior to date.

        Date should be in YYYY-MM-DD format."""
        self.get_all_sent()
        data = self.results
        sorttmp = [(a[3], a, i) for i, a in enumerate(data)]
        sorttmp.sort()
        sorttmp.reverse()
        from dateutil.parser import parse
        date = parse(date)
        for i, alias in enumerate(sorttmp):
            entry_date = dt.datetime.strptime(alias[0], SQL_DATE_FORMAT)
            if date > entry_date:
                break
        sorttmp = sorttmp[:i]
        results = [a[1] for a in sorttmp]
        self.write_sent(results)

    def remove_sent(self, rowids):
        """Delete addresses from the SQL txt file.

        Addresses to be deleted are specified by rowid."""
        rowids = [int(i) for i in rowids]
        self.get_all_sent()
        data = self.results
        pruned = [j for i, j in enumerate(data) if i not in rowids]
        self.write_sent(pruned)

    def write_sent(self, data, enc='utf-8'):
        """Write sent addresses to the txt file.

        This function looks for the number of columns in the data.  If there are 3,
        we assume that the data was scraped from an email using ingest_email, so the
        file is opened up in append mode and the data just added to the end.  If
        there are 4 columns, assume the data is either a full listing or a pruned
        listing, so open the file up in write mode and overwrite the existing
        data.

        Note (as of now) that unlike the SQL version of this function, no attempt
        is made to prune duplicate email entries."""
        # this is hackish
        if len(data[0]) == 3:
            k = 0
            mode = 'a'
        elif len(data[0]) == 4:
            k = 1
            mode = 'w'
        filename = self.cfg.get('sent', 'txtfile')
        filename = os.path.expanduser(filename)
        lines = []
        for datum in data:
            time = dt.datetime.strptime(datum[k+2], SQL_DATE_FORMAT)
            tmp = (datum[k+0], datum[k+1], time.strftime(LBDB_DATE_FORMAT))
            line = '\t'.join(tmp) + '\n'
            lines.append(line)
        try:
            import codecs
            fout = codecs.open(filename, mode, enc)
            fout.writelines(lines)
            fout.close()
        except:
            print "problem writing file %s" % filename
            sys.exit(13)

    def search_data(self, query, sortby):
        """Query the sent address txt file.

        Matches against name or email."""
        filename = self.cfg.get('sent', 'txtfile')
        data = ingest_LBDB(filename)
        results = self._filter_data_by_query(data, query)
        field_index = {'email':0, 'name':1, 'date':2}
        i = field_index[sortby]
        sorttmp = [(a[i], a) for a in results]
        sorttmp.sort()
        if sortby == 'date':
            sorttmp.reverse()
        results = [a[1] for a in sorttmp]
        self.results = results

    def _filter_data_by_query(self, data, query):
        """Search list data for query."""
        query = query.lower()
        results = [l for l in data
                   if l[0].lower().find(query) > -1 or l[1].lower().find(query) > -1]
        return results

class SentSqlData(DataSource):
    """Uses a sqlite database as the source of addresses."""
    def __init__(self, cfg, datatype='sentsql', getData=True):
        self.datatype = datatype
        self.sql = None
        self.cursor = None
        super(SentSqlData, self).__init__(cfg, getData=getData)

    def get_data(self):
        self._query_database()
        self.data = []

    def _query_database(self, make=False):
        """Connect to the sent mail SQL db file."""
        sqlfilename = os.path.expanduser(self.cfg.get('sent', 'sqlfile'))
        if not make and not os.path.exists(sqlfilename):
            return
        sql = sqlite3.connect(sqlfilename)
        self.sql = sql
        self.cursor = sql.cursor()

    def _create_tables(self):
        """Creates the default table in the SQL db."""
        try:
            self._query_database(make=True)
        except:
            print "can't make sqlite db"
            sys.exit(12)
        tables = self.cursor.execute('select name from sqlite_master')
        tlist = []
        for table in tables:
            tlist.append(table[0])
        if 'addresses' not in tlist:
            self.cursor.execute('create table addresses (email text, name text, '
                                'date text)')
            # think about not having the unique index be keyed to name as well
            self.cursor.execute('create unique index "post_email" on addresses '
                                '(email, name)')

    def get_all_sent(self):
        """Gets all data in the sent SQL db.

        Entries are prefixed by the rowid of the entry and are sorted
        alphabetically by email address."""
        if not self.sql:
            print 'no sent sql db'
            sys.exit(11)
        self.cursor.execute('select rowid, email, name, date from addresses order '
                            'by email')
        sqlchildren = self.cursor.fetchall()
        # self.cursor.close()
        results = [s for s in sqlchildren]
        self.results = results

    def search_data(self, query, sortby='name'):
        """Query the sent address SQL db.

        Matches against name or email."""
        if not self.cursor:
            return
        cfg = self.cfg
        displaydateformat = cfg.get('sent', 'date-format', raw=True)
        sort_terms = {
            'email': 'email',
            'name': 'name',
            'date': 'date desc', }
        # I don't know why I can't use parameter substitution for the order by
        # part.  I've made sure to ONLY accept email, name, or date as options
        # which should be secure.  Hopefully.
        querystr = "%%%s%%" % query.decode('utf-8')
        self.cursor.execute('select email, name, date from addresses where '
                            'name like ? or email like ? order by ' + sort_terms[sortby],
                            (querystr, querystr))
        sqlchildren = self.cursor.fetchall()
        self.cursor.close()
        results = []
        for row in sqlchildren:
            tmp = dt.datetime.strptime(row[-1], SQL_DATE_FORMAT)
            tmp = tmp.strftime(displaydateformat)
            # tmp += ' [sent]'
            result = (row[0], row[1], tmp)
            results.append(result)
        self.results = results
        # stick our results into data too, since SQL object doesn't have any
        # thing stored there until we do a search.
        self.data = results

    def write_sent(self, data):
        """Write sent addresses to the SQL db."""
        if not self.sql:
            self._create_tables()

        for datum in data:
            self.cursor.execute('insert or replace into addresses values'
                                '(?, ?, ?)', datum)
        self.sql.commit()
        self.cursor.close()

    def prune_sent_before_date(self, query):
        """Remove addresses from sent SQL db prior to date.

        Date should be in YYYY-MM-DD format."""
        if not self.sql:
            print 'no sent sql db'
            return
        querystr = "%s" % query.decode('utf-8')
        self.cursor.execute('delete from addresses where datetime(date) < ?',
                            (querystr,))
        self.sql.commit()
        self.cursor.close()

    def remove_sent(self, rowids):
        """Delete addresses from the SQL db.

        Addresses to be deleted are specified by rowid."""
        if not self.sql:
            print 'no sent sql db'
            return
        for rowid in rowids:
            self.cursor.execute('delete from addresses where rowid = ?',
                                (rowid,))
        self.sql.commit()
        self.cursor.close()

class ExtCommandData(DataSource):
    """Uses an external command as the source of addresses."""
    def __init__(self, cfg, helper, datatype='extCommand', getData=True):

        self.datatype = datatype
        self.helper = helper
        super(ExtCommandData, self).__init__(cfg, getData=getData)

    def get_data(self):
        helper = self.helper
        cmd = self.cfg.get(helper, 'cmd')
        try:
            helper_text = self.cfg.get(helper, 'text')
        except:
            helper_text = helper
        # indices of returned output to keep
        try:
            indices = self.cfg.get(helper, 'cols')
            # split the input and make it into a tuple of ints
            indices = tuple([int(i) for i in indices.split(',')])
        except:
            indices = (0, 1)
        try:
            ignore_first = self.cfg.getboolean(helper, 'ignore_first')
        except:
            ignore_first = False
        self.ignore_first = ignore_first
        self.indices = indices
        cmd = os.path.expanduser(cmd)
        self.query_cmd = cmd
        self.helper_text = helper_text

    def search_data(self, query, sortby=None):
        """Search with an external command.

        Depends on the external program that returns data in the proper
        format.  The command is set up in the config file.  The proper format for
        returned data is the same as the mutt query command expects except without
        the header line."""

        cmd = self.query_cmd
        cmd = '%s %s' % (cmd, query)
        cmd_ary = shlex.split(cmd)
        try:
            proc = sp.Popen(cmd_ary, stdout=sp.PIPE, stderr=sp.PIPE)
        except:
            self.results = []
        stdout, _ = proc.communicate()
        if stdout:
            helper_text = '\t%s' % self.helper_text
            stdout = stdout.decode('utf-8')
            # split by line
            # results = stdout.rstrip().split('\n')
            results = stdout.split('\n')
            if self.ignore_first:
                results = results[1:]
            # split lines by tabs, removing any blank lines
            self.results = [list(r.split('\t')) for r in results if r != '']
            self._process_results()
            # fill in blanks
            self.results = [['-' if i == '' else i for i in r] for r in self.results]
            self.results = [tuple(r + [helper_text,]) for r in self.results]
        else:
            self.results = []

    def _process_results(self):
        """Process returned results.

        Simple method to process the results returned from the command.  This
        can be replaced in a subclass if needed.  The default method just calls
        specific columns of the returned data."""
        # self.results = [r[:2] for r in self.results]
        self.results = [[r[i] for i in self.indices] for r in self.results]

def config_defaults():
    """Sets up config file defaults.

    These are used if a particular parameter can't be found in the config file,
    or if the config file doesn't exist."""
    parser = ConfigParser()
    parser.add_section('global')
    parser.set('global', 'helpers', 'mutt_alias, sent')
    parser.add_section('alias')
    parser.set('alias', 'files', '~/.mutt/aliases')
    parser.add_section('sent')
    parser.set('sent', 'format', 'sql')
    parser.set('sent', 'sortby', 'date')
    parser.set('sent', 'sqlfile', '~/.muttqt/sent.sqlite3')
    parser.set('sent', 'txtfile', '~/.muttqt/sent.txt')
    parser.set('sent', 'date-format', '%Y-%m-%d')
    parser.add_section('osx_abook')
    parser.set('osx_abook', 'cmd', 'contacts -m')
    parser.set('osx_abook', 'text', 'Address Book')
    parser.set('osx_abook', 'cols', '0,1')
    parser.set('osx_abook', 'ignore_first', 'True')
    parser.add_section('goobook')
    parser.set('goobook', 'cmd', 'goobook query')
    parser.set('goobook', 'text', 'Google')
    parser.set('goobook', 'cols', '0,1')
    parser.set('goobook', 'ignore_first', 'True')
    parser.add_section('mu')
    parser.set('mu', 'cmd', 'mu cfind -o mutt-ab')
    parser.set('mu', 'text', 'mu')
    parser.set('mu', 'cols', '0,1')
    parser.set('mu', 'ignore_first', 'on')
    return parser

def config_write(parser):
    """Writes out a default config file."""
    # write out a default config file if one doesn't exist already
    print "attempting to make default config file at %s" % CONFIGFILE
    if not os.path.exists(os.path.dirname(CONFIGFILE)):
        try:
            print "making directory"
            os.makedirs(os.path.dirname(CONFIGFILE))
        except:
            print "failed making directory"
            sys.exit(10)
    if not os.path.exists(CONFIGFILE):
        try:
            print "writing file"
            fout = open(CONFIGFILE, 'w')
            parser.write(fout)
            fout.close()
        except:
            print "failed writing file"
            sys.exit(10)
    else:
        print "config file already exists"

def config_read():
    """Reads the config file.

    Also fetches the configuration defaults."""
    parser = config_defaults()
    try:
        parser.read(os.path.expanduser(CONFIGFILE))
    except:
        print "problem reading config file"
        sys.exit(10)
    return parser

def ingest_email(lines):
    """Scrape email addresses from sent mails.

    Looks in the To:, CC:, and BCC: headers."""
    msg = email.message_from_string(lines)

    now = dt.datetime.now()
    time = now.strftime(SQL_DATE_FORMAT)

    to_addresses = []
    for header in ['to', 'cc', 'bcc']:
        if msg.has_key(header):
            to_addresses.extend(msg.get_all(header, []))
    to_addresses = [addr.decode('utf-8') for addr in to_addresses]

    to_addresses = email.utils.getaddresses(to_addresses)
    data = []
    for _, addr in enumerate(to_addresses):
        if addr[0] == '':
            name = addr[1].split('@')[0]
            entry = (addr[1].lower(), name, time)
        else:
            entry = (addr[1].lower(), addr[0], time)
        data.append(entry)

    return data

def ingest_LBDB(filename, enc='utf-8'):
    """Imports sent mail history from LBDB."""
    try:
        filename = os.path.expanduser(filename)
        import codecs
        fin = codecs.open(filename, 'r', enc)
        lines = fin.readlines()
        fin.close()
    except:
        print "problem opening file %s" % filename
        sys.exit(13)
    data = []
    for line in lines:
        # print line.rstrip().split('\t')
        addr, name, time = line.rstrip().split('\t')
        time = dt.datetime.strptime(time, LBDB_DATE_FORMAT)
        data.append((addr.lower(), name, time.strftime(SQL_DATE_FORMAT)))
    return data

def dump_file(data, filename):
    """Dump the slq file to an LBDB compatible text file."""
    filename = os.path.expanduser(filename)
    lines = []
    for datum in data:
        time = dt.datetime.strptime(datum[3], SQL_DATE_FORMAT)
        tmp = (datum[1], datum[2], time.strftime(LBDB_DATE_FORMAT))
        line = '\t'.join(tmp) + '\n'
        lines.append(line)
    if os.path.exists(filename):
        print "output file %s already exists" % filename
        sys.exit(13)
    try:
        import codecs
        fout = codecs.open(filename, 'w', 'utf-8')
        fout.writelines(lines)
        fout.close()
    except:
        print "problem writing file %s" % filename
        sys.exit(13)

def print_results(results, numbered=False):
    """Print search results."""
    i = len(results)
    print "%i matches:" % i
    if numbered:
        format_str = "%s\t%s\t%s\t%s"
    else:
        format_str = "%s\t%s\t%s"
    for i, string in enumerate(results):
        out = format_str % string
        # print out
        # print unicode(out)
        # uout = out.decode('utf-8')
        print out.encode('utf-8')
        # print uout.encode('ascii', 'ignore')

def configure_argparser():
    """Configures the parser of CLI arguments."""
    parser = argparse.ArgumentParser(
        description='Scrape email addresses from emails.')

    parser.add_argument('-V', '--version',
                        action="version",
                        version="%(prog)s {0} ({1})".format(__version__, __commit__),
                        help='prints version')

    parser.add_argument('-f', '--fetch',
                        dest='fetch',
                        metavar='FETCH_FILE',
                        type=file,
                        const=sys.stdin,
                        nargs='?',
                        help=('fetch addressees from a file.  If no file '
                              'is given, stdin is used.'))

    parser.add_argument('-q', '--query',
                        dest='query',
                        nargs=1,
                        default=False,
                        help='query the database')

    parser.add_argument('-s', '--sort',
                        dest='sortby',
                        nargs=1,
                        default=None,
                        help=("set the sort order of sent address results.  "
                              "valid choices are 'email', 'date', or 'name'"))

    parser.add_argument('-i', '--import',
                        dest='import_file',
                        default=False,
                        help='import addresses from an LBDB m_inmail file')

    parser.add_argument('-d', '--dump',
                        dest='dump_file',
                        default=False,
                        help='dump sent addresses to an LBDB compatible file')

    parser.add_argument('--print-sent',
                        dest='print_sent',
                        action='store_true',
                        help='print sent history with sql rowids')

    parser.add_argument('--remove-sent',
                        dest='remove_sent',
                        metavar='ROWID',
                        action='store',
                        nargs='*',
                        default=False,
                        help='remove entries by rowid from the sent history')

    parser.add_argument('--date-prune',
                        dest='date_prune',
                        metavar='YYYY-MM-DD',
                        default=False,
                        help='prune all entries prior to YYYY-MM-DD')

    parser.add_argument('--write-config',
                        dest='write_config',
                        action='store_true',
                        default=False,
                        help='write out a default config file to ~/.muttqt/muttqt.conf')

    return parser

def create_sent_source(cfg):
    sent_file_format = cfg.get('sent', 'format')

    if sent_file_format == 'sql':
        sent_source = SentSqlData(cfg)
    elif sent_file_format == 'text':
        sent_source = SentTxtData(cfg)
    else:
        #error TODO
        pass
    return sent_source

def main(argv=None):
    """Main function."""
    if argv is None:
        argv = sys.argv

    parser = configure_argparser()
    args = parser.parse_args()

    # get configuration data
    cfg = config_read()
    sent_source = create_sent_source(cfg)

    if args.print_sent:
        sent_source.get_all_sent()
        sent_source.print_results(numbered=True)

    elif args.write_config:
        config_write(cfg)

    elif args.date_prune:
        results = sent_source.prune_sent_before_date(args.date_prune)

    elif args.remove_sent:
        results = sent_source.remove_sent(args.remove_sent)

    elif args.dump_file:
        sent_source.get_all_sent()
        dump_file(sent_source.results, args.dump_file)

    elif args.fetch or args.import_file:
        if args.import_file:
            data = ingest_LBDB(args.import_file)
        else:
            # read our lines from stdin or the file passed
            lines = ''.join(args.fetch.readlines())
            data = ingest_email(lines)

        sent_source.write_sent(data)

    elif args.query:
        helpers = [h.strip() for h in cfg.get('global', 'helpers').split(',')]

        results = []
        query = args.query[0]
        for helper in helpers:
            data = []
            if helper == 'mutt_alias':
                aliasdata = AliasData(cfg)
                aliasdata.search_data(query)
                data = aliasdata.results
            elif helper in ['osx_abook', 'goobook',]:
                extern_source = ExtCommandData(cfg, helper)
                extern_source.search_data(query)
                data = extern_source.results
            elif helper == 'sent':
                sortby = cfg.get('sent', 'sortby')
                if args.sortby:
                    sortby = args.sortby[0]
                sent_source.search_data(query, sortby)
                data = sent_source.results
            else:
                # this is potentially risky, but we'll try to parse any other
                # helpers in the config file as external commands
                try:
                    extern_source = ExtCommandData(cfg, helper)
                    extern_source.search_data(query)
                    data = extern_source.results
                except:
                    pass
            results.extend(data)

        print_results(results)

    return 0

if __name__ == "__main__":
    sys.exit(main())
